# xrenner model configuration file
# Use regex surrounded by slashes for all values unless otherwise specified
# Author: Amir Zeldes

# Data in this model comes from Coptic Scriptorium - see licenses/

[main]
### General function label settings ###
subject_func=/nsubj/
apposition_func=/appos/
possessive_func=/poss/
# Function for the second conjunct, NOT the conjunction; used to propagate function from first conjunct
conjunct_func=/conj/
# Dependency function identifying a coordinating conjunction
coord_func=/cc/
# Dependency function for determiners (if this function also matches functions in mod_func it will NOT used to rule out incompatible modifiers)
det_func=/det|poss/
# Decimal point separator in this language, e.g. period or comma
decimal_sep=none
# Thousands separator in this language, e.g. comma or period
thousand_sep=none


### Markable Detection ###
# POS categories to consider for markable heads
mark_head_pos=/^(N(PROP)?|PPER.?|PPOS)$/
# POS categories to consider for markable head only if dependency function is not (!) ...
# This is NOT a regular expression
pos_func_heads=NUM!num;NUM!number;NUM!dep;NUM!discourse
# POS categories for verbs, only considered if seeking verbal antecedents for definite NPs with no antecedent is switched on
verb_head_pos=/^V.*$/
# Dependency functions that rule out being a markable head
mark_forbidden_func=/amod/
# Dependency functions that terminate markable sequence propagation
non_link_func=/cc|acl|nsubj|cop|case|aux|dep|punct|conj|appos|mark|xcomp|vmod|advcl|tmod|discourse|advmod|parataxis|neg/
# Token values that terminate markable sequence propagation
non_link_tok=/NONE/
# Dependency functions for which stoplist is checked to rule out spurious markables and markable extensions are forbidden
stop_func=/amod|nn|xcomp|root|mwe|dep/
# Postprocess parser input to ensure tokens inside known entities depend on the entity head?
postprocess_parser=False
# Func substitutions - replace function depending on POS and direction of head - NOT a regular expression
func_substitute_backward=none/none/none
func_substitute_forward=none/none/none
# Affix tokens to strip from markable core text
core_prefixes=/^ ?(ⲡ|ⲧ|ⲛ)( |$)/
core_suffixes=/ ((ϥ|ⲥ) ?)*$/
# Functions that can be stripped when determining atomicity, e.g. if 'police department' is atomic, then a modified 'rich police department' is too
non_essential_mod_func=/amod/


### Entity Detection ###
# Default entity
default_entity=abstract
# Parts of speech for proper nouns
proper_pos=/NPROP/
# Parts of speech for pronouns
pronoun_pos=/^(PPER.*|PPOS)/
# What can an article look like which is not part of a person's actual name?
articles=/^(ⲟⲩ|ⲡ|ⲧ|ⲛ)$/
# What can articles or modifiers look like which entail definiteness?
definite_articles=/^((ⲡ|ⲧ|ⲛ)(ⲉ(ⲕ|ϥ|ⲥ|ⲓ|ⲛ|ⲩ|ⲧⲛ)?)?)$/
# Are people and place names in this language capitalized?
cap_names=False
# Ad hoc lemmatization rules - cascade of POS dependent string replace rules to use if no lemma is available in input
lemma_rules=NNP?S/xes$/x/;NNP?S/sses$/ss/;NNP?S/ies$/y/;NNP?S/s$//
# Edit morphology information - cascade of string replace rules to use on the morph field in conll data if available
morph_rules=_/_
# Auto lower case bahvior for lemmas when using lemma rules. Possible values: all, except_all_caps, none
auto_lower_lemma=none
# Entity to guess for unknown acronyms
all_caps_entity=person
# Maximum of substring suffix used on unknown heads to establish category (e.g. 4 catches -ness as usually abstract)
max_suffix_length=3

# Default name and agreement for persons and places
person_def_entity=person
place_def_entity=place
time_def_entity=time
object_def_entity=object
organization_def_entity=organization
quantity_def_entity=quantity
event_def_entity=event
abstract_def_entity=abstract
person_def_agree=male
place_def_agree=inanim
time_def_agree=inanim
organization_def_agree=inanim
object_def_agree=inanim
quantity_def_agree=plural

### Coreference Detection ###
# Modifier functions that require strictly identical heads for coreference
ident_mod_func=/^(num|poss)$/
# What POS categories should allow lemma matching of heads for coreference?
lemma_match_pos=/^N$/
# Dependency functions that are interpreted as modifiers for compatible modifier checks
mod_func=/nmod|num/
# Tokens that mark opening and closing quotation for direct speech detection
open_quote=/^(["'”’]|``)$/
close_quote=/^(["'”’]|'')$/
# Tokens used to identify a question sentence
question_mark=/^\?$/
# Markables forbidden to have antecedents - semicolon separated patterns of initial (^x), final ($x) or head(@x) POS + text that rule out antecedent. 
# Use ! for negation, & for multiple criteria
no_antecedent=@none/none
# Are indefinite markables allowed to be anaphors (i.e. can they have antecedents)?
allow_indef_anaphor=False
# Are indefinite markables allowed to be anaphors via isa? (only used if allow_indef_anaphor is True)
allow_indef_isa=False
# Should we match Title Case entities to acronyms made of each token's initial letters?
match_acronyms=False
# Words to ignore in acronym matching, e.g. 'of' in Federal Bureau *of* Investigation <- FBI
ignore_in_acronym=/NONE/
# Should it be possible for a later mention to include lexical modifiers not present in the antecedent?
no_new_modifiers=False
# Should exceptional new modifiers listed in the new_modifiers file be allowed in subsequent mentions? (only used if no_new_modifiers=True)
use_new_modifier_exceptions=False
# Do proper noun modifiers have to match exactly across mentions? (NB: this may include proper modifiers such as Mr.!! Often leaving this False is better)
proper_mod_must_match=True

### Agreement Class Detection ###
pos_agree_mapping=NPS>plural;NNPS>plural;NNS>plural
agree_entity_mapping=none>none
default_agree=M
# Agreement classes compatible with unknown agreement - all other classes will require strict agreement
agree_with_unknown=/M|F|PL/
# Strict disagree sets, e.g. male+female; note that putting singular/plural here disrupts possible isa-table connections between the two.
# Separate each pair internally with plus, and multiple pairs with semicolon
never_agree_pairs=PL+M;PL+F
# Agreement classes incompatible with person type entities
no_person_agree=/NONE/
# Agreement class for coordinate/aggregate entities; plain string NOT a regex (use underscore to assign no special class)
aggregate_agree=PL
# Does isa matching of subclasses require morphological agreement?
isa_subclass_agreement=True

### Postprocessing ###
remove_head_func=/xnn/
remove_child_func=/xcop/
remove_singletons=False
remove_cataphora=False
add_appos_envelopes=False
seek_verb_for_defs=True
stemmer_deletes=/none/
remove_coordinate_envelopes=True
